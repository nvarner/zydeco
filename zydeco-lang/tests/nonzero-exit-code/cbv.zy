codata Monad (M: VType -> CType) where
  | .return(): forall (A: VType) . A -> M A
  | .bind(): forall (A: VType) (A': VType) . U (M A) -> U (A -> M A') -> M A'
end

// def mret : Monad Ret =
//   comatch
//   | .return A a -> ret a
//   | .bind A A' m f ->
//     do x <- ! m;
//     ! f x
//   end
// end

data Exception where
  | TypeError()
  | FreeVariable()
end

data State where
  | State()
end

// alias MExn (A: VType) = Ret (Either Exception A) end

codata MExn (A: VType) where
  | .mexn(): State -> Ret (Either Exception (Pair State A))
end

def fn mexn : Monad MExn =
  comatch
  | .return() -> fn A a ->
    comatch
    | .mexn() -> fn s -> ret Right(Cons(s, a))
    end
  | .bind() -> fn A A' m f -> comatch
    | .mexn() -> fn s -> 
      do x <- ! m .mexn() s;
      match x
      | Left(e) -> ret Left(e)
      | Right(v) ->
        match v
        | Cons(s', a) -> ! f a .mexn() s'
        end
      end
    end
  end
end

def fn mk_mexn (v: U (State -> Ret (Either Exception (Pair State Value)))) : MExn Value =
  comatch
  | .mexn() -> ! v
  end
end

data EnvT where
  | Empty()
  | Extend(String, Value, EnvT)
end

codata EnvO where
  | .lookup(): String -> Ret (Option Value)
  | .extend(): String -> Value -> EnvO
end

def rec fn envo (env: EnvT) : EnvO =
  comatch
  | .lookup() -> fn x ->
    match env
    | Empty() -> ret None()
    | Extend(x', v, env') ->
      do is-eq? <- ! str_eq x x';
      match is-eq?
      | True() -> ret Some(v)
      | False() -> ! envo env' .lookup() x
      end
    end
  | .extend() -> fn x v ->
    ! envo Extend(x, v, env)
  end
end

data Value where
  | Bool(Bool)
  | Lam(U EnvO, String, Term)
end

data Term where
  | Var(String)
  | Lam(String, Term)
  | App(Term, Term)
  | Bool(Bool)
  | If(Term, Term, Term)
end

codata Interp where
  | .run() : MExn Value
end

def fn raise (exn: Exception) : MExn Value =
  ! mk_mexn { fn s -> ret Left(exn) }
end

def rec fn interp (env: U EnvO) (t: Term) : Interp =
  comatch
  | .run() ->
    match t
    | Var(x) ->
      do x? <- ! env .lookup() x;
      match x?
      | None() -> ! raise FreeVariable()
      | Some(v) ->
        ! mexn .return() @(Value) v
        // ret[mexn] v
      end
    | Lam(x, t) ->
      ! mexn .return() @(Value) Lam(env, x, t)
      // ret[mexn] Lam(env, x, t)
    | App(t1, t2) ->
      let m1 = { ! interp env t1 .run() .mexn() };
      ! mexn .bind() @(Value) @(Value) { ! mk_mexn m1 } { fn v1 ->
        // do[mexn] v1 <- ! interp env t1 .run;
        let m2 = { ! interp env t2 .run() .mexn() };
        ! mexn .bind() @(Value) @(Value) { ! mk_mexn m2 } { fn v2 ->
          // do[mexn] v2 <- ! interp env t2 .run;
          match v1
          | Bool(b) -> ! raise TypeError()
          | Lam(env', x, t) ->
            ! interp { ! env' .extend() x v2 } t .run()
          end
        }
      }
    | Bool(b) ->
      ! mexn .return() @(Value) Bool(b)
      // ret[mexn] Bool(b)
    | If(t1, t2, t3) ->
      let m1 = { ! interp env t1 .run() .mexn() };
      ! mexn .bind() @(Value) @(Value) { ! mk_mexn m1 } { fn v1 ->
        // do[mexn] v1 <- ! interp env t1 .run;
        match v1
        | Bool(b) ->
          match b
          | True() -> ! interp env t2 .run()
          | False() -> ! interp env t3 .run()
          end
        | Lam(env', x, t) -> ! raise TypeError()
        end
      }
    end
  end
end

main
  let term : Term = App(Lam("x", Var("x")), Bool(True()));
  let env : U EnvO = { ! envo Empty() };
  do sv? <- ! interp env term .run() .mexn() State();
  match sv?
  | Left(_) -> ! panic "error"
  | Right(sv) ->
    match sv
    | Cons(s, v) ->
      match v
      | Bool(b) ->
        match b
        | True() -> ! exit 0
        | False() -> ! panic "wrong value"
        end
      | Lam(_, _, _) -> ! panic "should be bool"
      end
    end
  end

  // let w : Term = Lam("x", App(Var("x"), Var("x")));
  // let term : Term = App(w, w);
  // let env : U EnvO = { ! envo Empty() };
  // do v? <- ! interp env term .run() .mexn();
  // ! panic "unreachable"
end
