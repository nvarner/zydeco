codata Monad (M: VType -> CType) where
  | .return(): forall (A: VType). A -> M A
  | .bind(): forall (A: VType) (A': VType) . U (M A) -> U (A -> M A') -> M A'
end

// def mret : Monad Ret =
//   comatch
//   | .return A a -> ret a
//   | .bind A A' m f ->
//     do x <- ! m;
//     ! f x
//   end
// end

data Exception where
  | TyprError()
  | FreeVariable()
end

alias MExn (A: VType) = Ret (Either Exception A) end

def fn mexn : Monad MExn =
  comatch
  | .return() -> fn A a -> ret Right(a)
  | .bind() -> fn A A' m f ->
    do x <- ! m;
    match x
    | Left(e) -> ret Left(e)
    | Right(v) -> ! f v
    end
  end
end

data EnvT where
  | Empty()
  | Extend(String, Value, EnvT)
end

codata EnvO where
  | .lookup(): String -> Ret (Option Value)
  | .extend(): String -> Value -> EnvO
end

def rec fn envo (env: Env) : EnvO =
  comatch
  | .lookup() -> fn x ->
    match env
    | Empty() -> ret None()
    | Extend(x', v, env') ->
      do is-eq? <- ! str_eq x x';
      match is-eq?
      | True() -> ret Some(v)
      | False() -> ! envo env' .lookup() x
      end
    end
  | .extend() -> fn x v ->
    ! envo Extend(x, v, env)
  end
end

data Value where
  | Bool(Bool)
  | Lam(U EnvO, String, Term)
end

data Term where
  | Var(String)
  | Lam(String, Term)
  | App(Term, Term)
  | Bool(Bool)
  | If(Term, Term, Term)
end

codata Interp where
  | .run() : MExn Value
end

def fn raise (exn: Exception) : Interp =
  comatch
  | .run() -> ret Left(exn)
  end
end

def rec fn interp (env: U EnvO) (t: Term) : Interp =
  comatch
  | .run() ->
    match t
    | Var(x) ->
      do x? <- ! env .lookup() x;
      match x?
      | None() -> ! raise FreeVariable()
      | Some(v) ->
        ! mexn .return() @(Value) v
        // ret[mexn] v
      end
    | Lam(x, t) ->
      ! mexn .return() @(Value) Lam(env, x, t)
      // ret[mexn] Lam(env, x, t)
    | App(t1, t2) ->
      do m1 <- ! interp env t1 .run();
      ! mexn .bind() @(Value) @(Value) m1 { fn v1 ->
        // do[mexn] v1 <- ! interp env t1 .run;
        ! mexn .bind() @(Value) @(Value) m2 { fn v2 ->
          // do[mexn] v2 <- ! interp env t2 .run;
          match v1
          | Bool(b) -> ! raise TypeError()
          | Lam(env', x, t) ->
            ! interp { ! env' .extend() x v2 } t .run()
          end
        }
      }
    | Bool(b) ->
      ! mexn .return() @(Value) Bool(b)
      // ret[mexn] Bool(b)
    | If(t1, t2, t3) ->
      do m1 <- ! interp env t1 .run();
      ! mexn .bind() @(Value) @(Value) m1 { fn v1 ->
        // do[mexn] v1 <- ! interp env t1 .run;
        match v1
        | Bool(b) ->
          match b
          | True() -> ! interp env t2 .run()
          | False() -> ! interp env t3 .run()
          end
        | Lam(env', x, t) -> ! raise TypeError()
        end
      }
    end
  end
end

main
  let term : Term = App(Lam("x", Var("x")), Bool(True()));
  let env : U EnvO = { ! envo Empty() };
  do _ <- ! interp env term .run();
  ! exit 0
end
