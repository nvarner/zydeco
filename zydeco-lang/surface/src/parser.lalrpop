use crate::{
    arena::*,
    syntax::*,
    lexer::*,
    escape,
};

grammar<'input, 'arena>(
    input: &'input str,
    ar: &'arena mut Arena,
);

//* --------------------------------- Tokens --------------------------------- */

extern {
    type Location = usize;
    
    enum Tok<'input> {
        "UpperId" => Tok::UpperIdent(<&'input str>),
        "LowerId" => Tok::LowerIdent(<&'input str>),

        "where" => Tok::Where,
        "end" => Tok::End,
        "module" => Tok::Module,
        "use" => Tok::Use,
        "pub" => Tok::Pub,
        "extern" => Tok::Extern,
        "data" => Tok::Data,
        "codata" => Tok::Codata,
        "alias" => Tok::Alias,
        "define" => Tok::Define,
        "main" => Tok::Main,
        "let" => Tok::Let,
        "in" => Tok::In,
        "do" => Tok::Do,
        "ret" => Tok::Ret,
        "fn" => Tok::Fn,
        "rec" => Tok::Rec,
        "match" => Tok::Match,
        "comatch" => Tok::Comatch,
        "forall" => Tok::Forall,
        "exists" => Tok::Exists,
        "@" => Tok::At,
        "pack" => Tok::Pack,

        "NumLit" => Tok::NumLit(<&'input str>),
        "StrLit" => Tok::StrLit(<&'input str>),
        "CharLit" => Tok::CharLit(<&'input str>),

        "VType" => Tok::VType,
        "CType" => Tok::CType,

        "(" => Tok::ParenOpen,
        ")" => Tok::ParenClose,
        "[" => Tok::BracketOpen,
        "]" => Tok::BracketClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "=" => Tok::Equals,
        ";" => Tok::Semicolon,
        "!" => Tok::Force,
        "|" => Tok::Branch,
        "." => Tok::Dot,
        ".." => Tok::DotDot,
        "->" => Tok::Arrow,
        "<-" => Tok::Assign,
        "_?" => Tok::Hole,
    }
}

//* -------------------------------- Utilities ------------------------------- */

#[inline]
Sp<T>: Sp<T> = {
    <l:@L> <inner:T> <r:@R> => Sp {
        span: Span::new(l as u32, r as u32),
        inner,
    },
};

#[inline]
SepByDelim<Start, Sep, T, End>: Vec<T> = {
    Start <mut v: (<T> Sep)*> <last: T?> End => {
        match last {
            None => { },
            Some(t) => { v.push(t); }
        };
        v
    }
};

//* -------------------------------- Terminals ------------------------------- */

Int: i64 = <s:"NumLit"> => s.parse().unwrap();
String: String = <s:"StrLit"> => escape::apply_string_escapes(&s[1..s.len()-1]);
Char: char = <s:"CharLit"> => escape::apply_char_escapes(s);

//* ------------------------------- Identifiers ------------------------------ */

UpperId: String = "UpperId" => <>.into();
LowerId: String = "LowerId" => <>.into();
MixedId: String = { <UpperId>, <LowerId>, };

CtorName: String = <UpperId> => <>;
DtorName: String = "." <LowerId> => <>;

NameDef<T>: NameDef = {
    <T> => NameDef(<>.into()),
};

NameRef<T>: NameRef = {
    (<(<UpperId> ".")*> <T>) => NameRef (<>.0, <>.1),
};

//* --------------------------------- Pattern -------------------------------- */

PatternId: PatternId = {
    <Sp<Pattern>> => ar.pattern(<>),
}
Pattern: Pattern = {
};

//* ---------------------------------- Term ---------------------------------- */

GenBind: GenBind = {
    <rec:"rec"?> <fun:"fn"?> <binder:PatternId> <params:PatternId*>
    <ty:(":" <TermId>)?> <bindee: ("=" <TermId>)?> => GenBind {
        rec: rec.is_some(),
        fun: fun.is_some(),
        binder,
        params,
        ty,
        bindee,
    }
};

#[inline]
Literal: Literal = {
    <Int> => <>.into(),
    <String> => <>.into(),
    <Char> => <>.into(),
};

TermId: TermId = {
    <Sp<Term>> => ar.term(<>),
}
Term: Term = {
    "(" <Term> ")" => <>.into(),
    "(" <term:TermId> ":" <ty:TermId> ")" => Annotation {
        term, ty,
    }.into(),
    <NameRef<MixedId>> => <>.into(),
    "{" <TermId> "}" => Thunk(<>).into(),
    <ctor_name:NameRef<CtorName>> <args:SepByDelim<"(", ",", <TermId>, ")">> => Constructor(
        ctor_name, args
    ).into(),
    <Literal> => <>.into(),
};

//* -------------------------------- TopLevel -------------------------------- */

pub Zydeco: () = Sp<"!"> => ();
