// codata Monad (M : VType -> CType) where
//   | .return() : forall A . A ->  M(A)
//   | .bind() : forall A . forall A' . U(M(A)) -> U(A -> M(A')) -> M(A')
//   | .flatten() : forall A . U(M(U(M(A)))) -> M(A)
//   | .join() : forall A . forall A' . Pair (U(M(A))) (U(M(A'))) -> M(Pair A A')
// //   | .view() : forall A . forall B . U(M(A)) -> U(A -> B) -> B
// end

codata Result' (A : VType) where
  | .ok() : F A
  | .err() : OS
end

data SynVal where
  | Var(String)
  | True()
  | False()
  | ThunkV(SynComp)
end

data SynComp where
  | If(SynVal, SynComp, SynComp)
  | Force(SynVal)
  | Lam(String, SynComp)
  | App(SynComp, SynVal)
  | Return(SynVal)
  | Bind(SynComp, String, SynComp)
end

// How to deal with B
data SemVal (M : VType -> CType) where
  | True()
  | False()
  | ThunkV(Thunk(SemComp M))
end

codata SemComp (M : VType -> CType) where
  | .app(SemVal M) : SemComp M
  | .bind()        : M (SemVal M)
end

data Env (M : VType -> CType) where
  | Empty()
  | Cons(String, (SemVal M), (Env M))
end

codata Interpreter (M : VType -> CType) where
  | .valu(SynVal, Env M)  : M (SemVal M)
  | .comp(SynComp, Env M) : SemComp M
end

data SemValOption  where
  | True()
  | False()
  | ThunkV(Thunk(SemCompOption))
end

codata SemCompOption  where
  | .app(SemValOption) : SemCompOption
  | .bind()        : Result' (SemValOption)
end

def rec fn error_option (m : U(SemValOption -> (Result' (SemValOption)))) (a : SemValOption) : SemCompOption =
  comatch
    | .app(_) -> ! error_option m a
    | .bind() -> ! m a
  end
end

// def rec fn lookup (M : VType -> CType) (m : U((SemVal M) -> (M (SemVal M)))) (a : SemVal M) (x : String) (g : Env M) : M (SemVal M) =
//   match g
//   | Empty() -> ! m a
//   | Cons(y,v,g) ->
//     do b <- ! str_eq x y;
//     match b
//     | True() -> ! m v
//     | False() -> ! lookup @(M) m a x g
//     end
//   end
// end

// def fn sem_val_to_str (M : VType -> CType) (s : SemVal M) : F String =
//   match s
//   | True() -> ret "true"
//   | False() -> ret "false"
//   | ThunkV(_) -> ret "<thunk>"
//   end
// end

// def rec fn interp (M : VType -> CType) (m : U((SemVal M) -> (M (SemVal M)))) (a : SemVal M) : M (SemVal M) =
//   comatch
//     | .valu(v, g) -> (
//       match v
//       | Var(x) -> ! lookup @(M) m a x g
//       | True() -> ! m True()
//       | False() -> ! m False()
//       # Here we use the meta-language closures to capture the environment g 
//       | ThunkV(m') -> ! m ThunkV({ ! interp @(M) m a .comp(m', g) })
//       end
//     )
//     | .comp(m', g) -> (
//       match m'
//       | If(cond, mt, mf) -> (
//         match cond
//         | Var(_) -> ! m a
//         | True() -> ! interp @(M) m a .comp(mt, g)
//         | False() -> ! interp @(M) m a .comp(mf, g)
//         | ThunkV(_) -> ! m a
//         end
//       )
//       | Force(syn_val) -> (
//         do v? <- ! interp @(M) m a .valu(syn_val, g);
//         ! m v?
//         // match v? 
//         // | Ok(v) -> (
//         //   match v
//         //   | ThunkV(t) -> ! t
//         //   | True() -> ! error
//         //   | False() -> ! error
//         //   end
//         // )
//         // | Err() -> ! error
//         // end
//       )
//       | Return(syn_val) -> (
//         do v <- ! interp @(M) m a .valu(syn_val, g);
//         comatch
//           | .bind() -> ! m v
//           | .app(_) -> ! m a
//         end
//       )
//       | Bind(m', x, k) -> (
//         do v? <- ! interp @(M) m a .comp(m', g) .bind();
//         ! m v?
//         // match v?
//         // | Ok(v) -> ! interp .comp(k, Cons(x, v, g))
//         // | Err() -> ! error
//         // end
//       )
//       | Lam(x, m') -> (
//         comatch
//           | .app(v) -> (! interp @(M) m a .comp(m', Cons(x, v, g)))
//           | .bind() -> ! m a
//         end
//       )
//       | App(m, v) -> (
//         do v? <- ! interp @(M) m a .valu(v, g);
//         ! m v?
//         // match v?
//         // | Ok(v) -> ! interp .comp(m, g) .app(v)
//         // | Err() -> ! error
//         // end
//       )
//       end)
//     end
// end

main
  ! exit 0
end