codata Monad (M : VType -> CType) where
  | .return() : forall A . A ->  M(A)
  | .bind() : forall A . forall A' . U(M(A)) -> U(A -> M(A')) -> M(A')
  | .flatten() : forall A . U(M(U(M(A)))) -> M(A)
  | .join() : forall A . forall A' . Pair (U(M(A))) (U(M(A'))) -> M(Pair A A')
//   | .view() : forall A . forall B . U(M(A)) -> U(A -> B) -> B
end

data SynVal where
  | Var(String)
  | True()
  | False()
  | ThunkV(SynComp)
end

data SynComp where
  | If(SynVal, SynComp, SynComp)
  | Force(SynVal)
  | Lam(String, SynComp)
  | App(SynComp, SynVal)
  | Return(SynVal)
  | Bind(SynComp, String, SynComp)
end

// How to deal with B
data SemVal (M : VType -> CType) (B : CType) where
  | True()
  | False()
  | ThunkV(Thunk(SemComp M B))
end

codata SemComp (M : VType -> CType) (B : CType) where
  | .app(SemVal M B) : SemComp M B
  | .bind()        : B //M (SemVal M B)
end

data Env (M : VType -> CType) (B : CType) where
  | Empty()
  | Cons(String, (SemVal M B), (Env M B))
end

codata Interpreter (M : VType -> CType) (B : CType) where
  | .valu(SynVal, Env M B)  : B
  | .comp(SynComp, Env M B) : SemComp M B
end

def rec fn error (M : VType -> CType) (B : CType) (m : U((SemVal M B) -> B)) (a : SemVal M B) : SemComp M B =
  comatch
    | .app(_) -> ! error @(M) @(B) m a
    | .bind() -> ! m a
  end
end

def rec fn lookup (M : VType -> CType) (B : CType) (m : U((SemVal M B) -> B)) (a : SemVal M B) (x : String) (g : Env M B) : B =
  match g
  | Empty() -> ! m a
  | Cons(y,v,g) ->
    do b <- ! str_eq x y;
    match b
    | True() -> ! m v
    | False() -> ! lookup @(M) @(B) m a x g
    end
  end
end

def fn sem_val_to_str (M : VType -> CType) (B : CType) (s : SemVal M B) : F String =
  match s
  | True() -> ret "true"
  | False() -> ret "false"
  | ThunkV(_) -> ret "<thunk>"
  end
end

def rec fn interp (M : VType -> CType) (B : CType) (m : U((SemVal M B) -> B)) (a : SemVal M B) : B =
  comatch
    | .valu(v, g) -> (
      match v
      | Var(x) -> ! lookup @(M) @(B) m a x g
      | True() -> ! m True()
      | False() -> ! m False()
      # Here we use the meta-language closures to capture the environment g 
      | ThunkV(m') -> ! m ThunkV({ ! interp @(M) @(B) m a .comp(m', g) })
      end
    )
    | .comp(m', g) -> (
      match m'
      | If(cond, mt, mf) -> (
        match cond
        | Var(_) -> ! m a
        | True() -> ! interp @(M) @(B) m a .comp(mt, g)
        | False() -> ! interp @(M) @(B) m a .comp(mf, g)
        | ThunkV(_) -> ! m a
        end
      )
      | Force(syn_val) -> (
        do v? <- ! interp @(M) @(B) m a .valu(syn_val, g);
        ! m v?
        // match v? 
        // | Ok(v) -> (
        //   match v
        //   | ThunkV(t) -> ! t
        //   | True() -> ! error
        //   | False() -> ! error
        //   end
        // )
        // | Err() -> ! error
        // end
      )
      | Return(syn_val) -> (
        do v <- ! interp @(M) @(B) m a .valu(syn_val, g);
        comatch
          | .bind() -> ! m v
          | .app(_) -> ! m a
        end
      )
      | Bind(m', x, k) -> (
        do v? <- ! interp @(M) @(B) m a .comp(m', g) .bind();
        ! m v?
        // match v?
        // | Ok(v) -> ! interp .comp(k, Cons(x, v, g))
        // | Err() -> ! error
        // end
      )
      | Lam(x, m') -> (
        comatch
          | .app(v) -> (! interp @(M) @(B) m a .comp(m', Cons(x, v, g)))
          | .bind() -> ! m a
        end
      )
      | App(m, v) -> (
        do v? <- ! interp .valu(v, g);
        ! m v?
        // match v?
        // | Ok(v) -> ! interp .comp(m, g) .app(v)
        // | Err() -> ! error
        // end
      )
      end)
    end
end

main
  ! exit 0
end